/// <reference path="../../adonis-typings/redis.d.ts" />
/// <reference types="@adonisjs/application/build/adonis-typings" />
/// <reference types="@adonisjs/events/build/adonis-typings" />
import { EmitterContract } from '@ioc:Adonis/Core/Event';
import { ApplicationContract } from '@ioc:Adonis/Core/Application';
import { RedisConfig, HealthReportNode, RedisBaseManagerContract, RedisConnectionContract, RedisClusterConnectionContract } from '@ioc:Adonis/Addons/Redis';
/**
 * Redis manager exposes the API to interact with a redis server.
 */
export declare class RedisManager implements RedisBaseManagerContract {
    private application;
    private config;
    private emitter;
    /**
     * An array of connections with health checks enabled, which means, we always
     * create a connection for them, even when they are not used.
     */
    private healthCheckConnections;
    /**
     * A copy of live connections. We avoid re-creating a new connection
     * everytime and re-use connections.
     */
    activeConnections: {
        [key: string]: RedisClusterConnectionContract | RedisConnectionContract;
    };
    /**
     * A boolean to know whether health checks have been enabled on one
     * or more redis connections or not.
     */
    get healthChecksEnabled(): boolean;
    /**
     * Returns the length of active connections
     */
    get activeConnectionsCount(): number;
    constructor(application: ApplicationContract, config: RedisConfig, emitter: EmitterContract);
    /**
     * Validate config at runtime
     */
    private validateConfig;
    /**
     * Returns default connnection name
     */
    private getDefaultConnection;
    /**
     * Returns an existing connection using it's name or the
     * default connection,
     */
    private getExistingConnection;
    /**
     * Returns config for a given connection
     */
    private getConnectionConfig;
    /**
     * Returns redis factory for a given named connection
     */
    connection(name?: string): any;
    /**
     * Quit a named connection or the default connection when no
     * name is defined.
     */
    quit(name?: string): Promise<void>;
    /**
     * Disconnect a named connection or the default connection when no
     * name is defined.
     */
    disconnect(name?: string): Promise<void>;
    /**
     * Quit all connections
     */
    quitAll(): Promise<void>;
    /**
     * Disconnect all connections
     */
    disconnectAll(): Promise<void>;
    /**
     * Returns the report for all connections marked for `healthChecks`
     */
    report(): Promise<{
        displayName: string;
        health: {
            healthy: boolean;
            message: string;
        };
        meta: HealthReportNode[];
    }>;
    /**
     * Define a custom command using LUA script. You can run the
     * registered command using the "runCommand" method.
     */
    defineCommand(...args: Parameters<RedisConnectionContract['defineCommand']>): this;
    /**
     * Run a pre registered command
     */
    runCommand(command: string, ...args: any[]): any;
}
