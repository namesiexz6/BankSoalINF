"use strict";
/*
 * @adonisjs/redis
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RedisManager = void 0;
const utils_1 = require("@poppinss/utils");
const ioMethods_1 = require("../ioMethods");
const pubsubMethods_1 = require("../pubsubMethods");
const RedisConnection_1 = require("../RedisConnection");
const RedisClusterConnection_1 = require("../RedisClusterConnection");
/**
 * Redis manager exposes the API to interact with a redis server.
 */
class RedisManager {
    constructor(application, config, emitter) {
        this.application = application;
        this.config = config;
        this.emitter = emitter;
        /**
         * An array of connections with health checks enabled, which means, we always
         * create a connection for them, even when they are not used.
         */
        this.healthCheckConnections = [];
        /**
         * A copy of live connections. We avoid re-creating a new connection
         * everytime and re-use connections.
         */
        this.activeConnections = {};
        this.validateConfig();
        this.healthCheckConnections = Object.keys(this.config.connections).filter((connection) => this.config.connections[connection].healthCheck);
    }
    /**
     * A boolean to know whether health checks have been enabled on one
     * or more redis connections or not.
     */
    get healthChecksEnabled() {
        return this.healthCheckConnections.length > 0;
    }
    /**
     * Returns the length of active connections
     */
    get activeConnectionsCount() {
        return Object.keys(this.activeConnections).length;
    }
    /**
     * Validate config at runtime
     */
    validateConfig() {
        const validator = new utils_1.ManagerConfigValidator(this.config, 'redis', 'config/redis');
        validator.validateDefault('connection');
        validator.validateList('connections', 'connection');
    }
    /**
     * Returns default connnection name
     */
    getDefaultConnection() {
        return this.config.connection;
    }
    /**
     * Returns an existing connection using it's name or the
     * default connection,
     */
    getExistingConnection(name) {
        name = name || this.getDefaultConnection();
        return this.activeConnections[name];
    }
    /**
     * Returns config for a given connection
     */
    getConnectionConfig(name) {
        return this.config.connections[name];
    }
    /**
     * Returns redis factory for a given named connection
     */
    connection(name) {
        /**
         * Using default connection name when actual name is missing
         */
        name = name || this.getDefaultConnection();
        /**
         * Return cached connection
         */
        if (this.activeConnections[name]) {
            return this.activeConnections[name];
        }
        const config = this.getConnectionConfig(name);
        /**
         * Raise error if config for the given name is missing
         */
        if (!config) {
            throw new utils_1.Exception(`Define config for "${name}" connection inside "config/redis" file`);
        }
        /**
         * Create connection and store inside the connection pools
         * object, so that we can re-use it later
         */
        const connection = (this.activeConnections[name] = config.clusters
            ? new RedisClusterConnection_1.RedisClusterConnection(name, config, this.application)
            : new RedisConnection_1.RedisConnection(name, config, this.application));
        /**
         * Forward events to the application event emitter
         */
        connection.on('ready', ($connection) => this.emitter.emit('redis:ready', { connection: $connection }));
        connection.on('connect', ($connection) => this.emitter.emit('redis:connect', { connection: $connection }));
        connection.on('error', (error, $connection) => this.emitter.emit('redis:error', { error, connection: $connection }));
        connection.on('node:added', ($connection, node) => this.emitter.emit('redis:node:added', { node, connection: $connection }));
        connection.on('node:removed', (node, $connection) => this.emitter.emit('redis:node:removed', { node, connection: $connection }));
        connection.on('node:error', (error, address, $connection) => this.emitter.emit('redis:node:error', { error, address, connection: $connection }));
        /**
         * Stop tracking the connection after it's removed
         */
        connection.on('end', ($connection) => {
            delete this.activeConnections[$connection.connectionName];
            this.emitter.emit('redis:end', { connection: $connection });
        });
        /**
         * Return connection
         */
        return connection;
    }
    /**
     * Quit a named connection or the default connection when no
     * name is defined.
     */
    async quit(name) {
        const connection = this.getExistingConnection(name);
        if (!connection) {
            return;
        }
        return connection.quit();
    }
    /**
     * Disconnect a named connection or the default connection when no
     * name is defined.
     */
    async disconnect(name) {
        const connection = this.getExistingConnection(name);
        if (!connection) {
            return;
        }
        return connection.disconnect();
    }
    /**
     * Quit all connections
     */
    async quitAll() {
        await Promise.all(Object.keys(this.activeConnections).map((name) => this.quit(name)));
    }
    /**
     * Disconnect all connections
     */
    async disconnectAll() {
        await Promise.all(Object.keys(this.activeConnections).map((name) => this.disconnect(name)));
    }
    /**
     * Returns the report for all connections marked for `healthChecks`
     */
    async report() {
        const reports = (await Promise.all(this.healthCheckConnections.map((connection) => {
            return this.connection(connection).getReport(true);
        })));
        const healthy = !reports.find((report) => !!report.error);
        return {
            displayName: 'Redis',
            health: {
                healthy,
                message: healthy
                    ? 'All connections are healthy'
                    : 'One or more redis connections are not healthy',
            },
            meta: reports,
        };
    }
    /**
     * Define a custom command using LUA script. You can run the
     * registered command using the "runCommand" method.
     */
    defineCommand(...args) {
        this.connection().defineCommand(...args);
        return this;
    }
    /**
     * Run a pre registered command
     */
    runCommand(command, ...args) {
        return this.connection().runCommand(command, ...args);
    }
}
exports.RedisManager = RedisManager;
/**
 * Since types in AdonisJS are derived from interfaces, we take the leverage
 * of dynamically adding redis methods to the class prototype.
 */
pubsubMethods_1.pubsubMethods.forEach((method) => {
    RedisManager.prototype[method] = function redisManagerProxyFn(...args) {
        return this.connection()[method](...args);
    };
});
ioMethods_1.ioMethods.forEach((method) => {
    RedisManager.prototype[method] = function redisManagerProxyFn(...args) {
        return this.connection()[method](...args);
    };
});
