/// <reference path="../../adonis-typings/redis.d.ts" />
/// <reference types="@adonisjs/application/build/adonis-typings" />
/// <reference types="node" />
import { EventEmitter } from 'events';
import { Redis, Cluster } from 'ioredis';
import { ApplicationContract } from '@ioc:Adonis/Core/Application';
import { HealthReportNode, PubSubChannelHandler, PubSubPatternHandler } from '@ioc:Adonis/Addons/Redis';
/**
 * Abstract factory implements the shared functionality required by Redis cluster
 * and normal Redis connections.
 */
export declare abstract class AbstractConnection<T extends Redis | Cluster> extends EventEmitter {
    connectionName: string;
    /**
     * Reference to the main ioRedis connection
     */
    ioConnection: T;
    /**
     * Reference to the main ioRedis subscriber connection
     */
    ioSubscriberConnection?: T;
    /**
     * Number of times `getReport` was deferred, at max we defer it for 3 times
     */
    private deferredReportAttempts;
    /**
     * The last error emitted by the `error` event. We set it to `null` after
     * the `ready` event
     */
    private lastError?;
    /**
     * IoCResolver to resolve bindings
     */
    private resolver;
    /**
     * A list of active subscription and pattern subscription
     */
    protected subscriptions: Map<string, PubSubChannelHandler>;
    protected psubscriptions: Map<string, PubSubPatternHandler>;
    /**
     * Returns an anonymous function by parsing the IoC container
     * binding.
     */
    private resolveIoCBinding;
    /**
     * Returns the memory usage for a given connection
     */
    private getUsedMemory;
    /**
     * Returns status of the main connection
     */
    get status(): string;
    /**
     * Returns status of the subscriber connection or
     * undefined when there is no subscriber
     * connection
     */
    get subscriberStatus(): string | undefined;
    /**
     * Parent class must implement makeSubscriberConnection
     */
    protected abstract makeSubscriberConnection(): void;
    constructor(connectionName: string, application: ApplicationContract);
    /**
     * The events proxying is required, since ioredis itself doesn't cleanup
     * listeners after closing the redis connection and since closing a
     * connection is an async operation, we have to wait for the `end`
     * event on the actual connection and then remove listeners.
     */
    protected proxyConnectionEvents(): void;
    /**
     * Making the subscriber connection and proxying it's events. The method
     * results in a noop, in case of an existing subscriber connection.
     */
    protected setupSubscriberConnection(): void;
    /**
     * Gracefully end the redis connection
     */
    quit(): Promise<void>;
    /**
     * Forcefully end the redis connection
     */
    disconnect(): Promise<void>;
    /**
     * Subscribe to a given channel to receive Redis pub/sub events. A
     * new subscriber connection will be created/managed automatically.
     */
    subscribe(channel: string, handler: PubSubChannelHandler | string): void;
    /**
     * Unsubscribe from a channel
     */
    unsubscribe(channel: string): Promise<unknown>;
    /**
     * Make redis subscription for a pattern
     */
    psubscribe(pattern: string, handler: PubSubPatternHandler | string): void;
    /**
     * Unsubscribe from a given pattern
     */
    punsubscribe(pattern: string): any;
    /**
     * Returns report for the connection
     */
    getReport(checkForMemory?: boolean): Promise<HealthReportNode>;
    /**
     * Publish the pub/sub message
     */
    publish(channel: string, message: string, callback?: any): Promise<number>;
    /**
     * Define a custom command using LUA script. You can run the
     * registered command using the "runCommand" method.
     */
    defineCommand(...args: Parameters<Redis['defineCommand']>): this;
    /**
     * Run a pre registered command
     */
    runCommand(command: string, ...args: any[]): any;
}
