"use strict";
/*
 * @adonisjs/i18n
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.I18nManager = void 0;
/// <reference path="../../adonis-typings/index.ts" />
const utils_1 = require("@poppinss/utils");
const I18n_1 = require("../I18n");
const Helpers_1 = require("../Helpers");
const Fs_1 = require("../Loaders/Fs");
const Negotiator_1 = require("../Negotiator");
const Icu_1 = require("../Formatters/Message/Icu");
class I18nManager {
    constructor(application, emitter, logger, config) {
        this.application = application;
        this.emitter = emitter;
        this.logger = logger;
        this.config = config;
        /**
         * A set of formatters added from outside in
         */
        this.extendedFormatters = new Map();
        /**
         * A set of loaders added from outside in
         */
        this.extendedLoaders = new Map();
        /**
         * Translations fetched using the registered loaders. We load
         * them when "loadTranslations" or "reloadTranslations"
         * is called.
         */
        this.translations = {};
        /**
         * Find if translations has been loaded atleast once or not
         */
        this.loadedTranslations = false;
        /**
         * Reference to the default locale defined inside the config file
         */
        this.defaultLocale = this.config.defaultLocale;
        /**
         * Pretty prints the missing translation message on the console
         */
        this.prettyPrint = Helpers_1.prettyPrint;
        /**
         * An array of supported locales inferred from the fallback locales
         * object + the translations directories.
         *
         * The array is only used when the config doesn't have an explicit
         * value.
         */
        this.inferredLocales = [];
        this.validateConfig();
    }
    /**
     * Validate top level config values to be available when
     * instantiating the manager class
     */
    validateConfig() {
        if (!this.config) {
            throw new utils_1.Exception('Missing i18n config. Make sure define it inside "config/i18n.ts" file');
        }
        if (!this.config.loaders) {
            throw new utils_1.Exception('Missing "loaders" config inside "config/i18n.ts" file');
        }
        if (!this.config.defaultLocale) {
            throw new utils_1.Exception('Missing "defaultLocale" value inside "config/i18n.ts" file');
        }
        if (!this.config.translationsFormat) {
            throw new utils_1.Exception('Missing "translationsFormat" value inside "config/i18n.ts" file');
        }
    }
    /**
     * Creates an instance of the extended formatter
     */
    createExtendedFormatter(name) {
        if (!this.extendedFormatters.has(name)) {
            throw new utils_1.Exception(`Invalid formatter "${name}"`, 500, 'E_INVALID_INTL_FORMATTER');
        }
        return this.extendedFormatters.get(name)(this, this.config);
    }
    /**
     * Conditionally pushes to the inferred locales avoiding duplicates.
     *
     * Yes, we can use a set. However, we are trying to avoid converting the
     * set to an array during "getSupportedLocales" call. Since that method
     * is used more often than we push to an array.
     */
    pushToInferredLocales(locale) {
        if (!this.inferredLocales.includes(locale)) {
            this.inferredLocales.push(locale);
        }
    }
    /**
     * Returns an instance of the Icu formatter
     */
    createIcuFormatter() {
        return new Icu_1.IcuFormatter();
    }
    /**
     * Creates an instance of the translations formatter based upon whats
     * defined inside the user config
     */
    getTranslationsFormatter(name) {
        switch (name) {
            case 'icu':
                return this.createIcuFormatter();
            default:
                return this.createExtendedFormatter(name);
        }
    }
    /**
     * Creates an instance of the extended loader
     */
    createExtendedLoader(name, config) {
        if (!this.extendedLoaders.has(name)) {
            throw new utils_1.Exception(`Invalid loader "${name}"`, 500, 'E_INVALID_INTL_LOADER');
        }
        return this.extendedLoaders.get(name)(this, config);
    }
    /**
     * Returns an instance of the FS loader
     */
    createFsLoader(config) {
        return new Fs_1.FsLoader(config);
    }
    /**
     * Creates an instance of the translations loader based upon whats
     * defined inside the user config
     */
    getLoader(name, config) {
        switch (name) {
            case 'fs':
                return this.createFsLoader(config);
            default:
                return this.createExtendedLoader(name, config);
        }
    }
    /**
     * An array of locales supported by the application
     */
    supportedLocales() {
        return this.config.supportedLocales || this.inferredLocales;
    }
    /**
     * Load translations using the configured loaders
     */
    async loadTranslations() {
        if (!this.loadedTranslations) {
            this.logger.trace('loading translations');
            await this.reloadTranslations();
        }
    }
    /**
     * Returns an object of all the loaded translations
     */
    getTranslations() {
        return this.translations;
    }
    /**
     * Returns an object of translations for a given locale
     */
    getTranslationsFor(locale) {
        return this.translations[locale] || {};
    }
    /**
     * Reload translations from the registered loaders
     */
    async reloadTranslations() {
        const translationsStack = await Promise.all(Object.keys(this.config.loaders)
            .filter((loader) => {
            return this.config.loaders[loader]?.enabled;
        })
            .map((loader) => {
            this.logger.trace('loading translations from "%s" loader', loader);
            return this.getLoader(loader, this.config.loaders[loader]).load();
        }));
        /**
         * Set flag to true
         */
        this.loadedTranslations = true;
        /**
         * Empty the existing translations object
         */
        this.translations = {};
        /**
         * Reset to initialize state
         */
        if (!this.config.supportedLocales) {
            this.inferredLocales = [this.defaultLocale].concat(this.config.fallbackLocales ? Object.keys(this.config.fallbackLocales) : []);
        }
        /**
         * Shallow merge translations from all the loaders
         */
        translationsStack.forEach((translations) => {
            if (!translations) {
                return;
            }
            Object.keys(translations).forEach((lang) => {
                /**
                 * Collect inferred locales when not defined explicitly
                 */
                if (!this.config.supportedLocales) {
                    this.pushToInferredLocales(lang);
                }
                /**
                 * Initialize language with an empty object
                 */
                if (!this.translations[lang]) {
                    this.translations[lang] = {};
                }
                Object.assign(this.translations[lang], translations[lang]);
            });
        });
    }
    /**
     * Returns an instance of the translations formatter for the
     * active formatter
     */
    getFormatter() {
        if (!this.formatter) {
            this.logger.trace('configuring formatter "%s"', this.config.translationsFormat);
            this.formatter = this.getTranslationsFormatter(this.config.translationsFormat);
        }
        return this.formatter;
    }
    /**
     * Negotiates the user language against the supported
     * locales and returns the best match or null if there
     * is no match.
     */
    getSupportedLocale(userLanguage) {
        return (0, Negotiator_1.language)(userLanguage, this.supportedLocales());
    }
    /**
     * Returns the fallback locale for a given locale. Returns the default
     * locale when no fallback is defined
     */
    getFallbackLocale(locale) {
        const fallbacks = this.config.fallbackLocales;
        return fallbacks ? fallbacks[locale] || this.defaultLocale : this.defaultLocale;
    }
    /**
     * Returns an instance of I18n for a given locale
     */
    locale(locale) {
        return new I18n_1.I18n(locale, this.emitter, this.logger, this);
    }
    extend(name, type, callback) {
        this.logger.trace('extending i18n by adding "%s" %s', name, type);
        if (type === 'loader') {
            this.extendedLoaders.set(name, callback);
        }
        else {
            this.extendedFormatters.set(name, callback);
        }
    }
}
exports.I18nManager = I18nManager;
