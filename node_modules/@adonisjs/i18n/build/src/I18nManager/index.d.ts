/// <reference path="../../adonis-typings/index.d.ts" />
/// <reference types="@adonisjs/application/build/adonis-typings" />
/// <reference types="@adonisjs/events/build/adonis-typings" />
/// <reference types="@adonisjs/logger/build/adonis-typings/logger" />
import { LoggerContract } from '@ioc:Adonis/Core/Logger';
import { EmitterContract } from '@ioc:Adonis/Core/Event';
import { ApplicationContract } from '@ioc:Adonis/Core/Application';
import { I18nConfig, I18nManagerContract, LoaderExtendCallback, FormatterExtendCallback, TranslationsFormatterContract } from '@ioc:Adonis/Addons/I18n';
import { prettyPrint } from '../Helpers';
export declare class I18nManager implements I18nManagerContract {
    application: ApplicationContract;
    private emitter;
    private logger;
    config: I18nConfig;
    /**
     * A set of formatters added from outside in
     */
    private extendedFormatters;
    /**
     * A set of loaders added from outside in
     */
    private extendedLoaders;
    /**
     * Reference to the formatter used by the user application. We initialize
     * it lazily and then cache it.
     */
    private formatter;
    /**
     * Translations fetched using the registered loaders. We load
     * them when "loadTranslations" or "reloadTranslations"
     * is called.
     */
    private translations;
    /**
     * Find if translations has been loaded atleast once or not
     */
    private loadedTranslations;
    /**
     * Reference to the default locale defined inside the config file
     */
    defaultLocale: string;
    /**
     * Pretty prints the missing translation message on the console
     */
    prettyPrint: typeof prettyPrint;
    /**
     * An array of supported locales inferred from the fallback locales
     * object + the translations directories.
     *
     * The array is only used when the config doesn't have an explicit
     * value.
     */
    private inferredLocales;
    constructor(application: ApplicationContract, emitter: EmitterContract, logger: LoggerContract, config: I18nConfig);
    /**
     * Validate top level config values to be available when
     * instantiating the manager class
     */
    private validateConfig;
    /**
     * Creates an instance of the extended formatter
     */
    private createExtendedFormatter;
    /**
     * Conditionally pushes to the inferred locales avoiding duplicates.
     *
     * Yes, we can use a set. However, we are trying to avoid converting the
     * set to an array during "getSupportedLocales" call. Since that method
     * is used more often than we push to an array.
     */
    private pushToInferredLocales;
    /**
     * Returns an instance of the Icu formatter
     */
    private createIcuFormatter;
    /**
     * Creates an instance of the translations formatter based upon whats
     * defined inside the user config
     */
    private getTranslationsFormatter;
    /**
     * Creates an instance of the extended loader
     */
    private createExtendedLoader;
    /**
     * Returns an instance of the FS loader
     */
    private createFsLoader;
    /**
     * Creates an instance of the translations loader based upon whats
     * defined inside the user config
     */
    private getLoader;
    /**
     * An array of locales supported by the application
     */
    supportedLocales(): string[];
    /**
     * Load translations using the configured loaders
     */
    loadTranslations(): Promise<void>;
    /**
     * Returns an object of all the loaded translations
     */
    getTranslations(): {
        [lang: string]: Record<string, string>;
    };
    /**
     * Returns an object of translations for a given locale
     */
    getTranslationsFor(locale: string): Record<string, string>;
    /**
     * Reload translations from the registered loaders
     */
    reloadTranslations(): Promise<void>;
    /**
     * Returns an instance of the translations formatter for the
     * active formatter
     */
    getFormatter(): TranslationsFormatterContract;
    /**
     * Negotiates the user language against the supported
     * locales and returns the best match or null if there
     * is no match.
     */
    getSupportedLocale(userLanguage: string | string[]): string | null;
    /**
     * Returns the fallback locale for a given locale. Returns the default
     * locale when no fallback is defined
     */
    getFallbackLocale(locale: string): string;
    /**
     * Returns an instance of I18n for a given locale
     */
    locale(locale: string): any;
    /**
     * Extend by adding custom formatters and loaders
     */
    extend(name: string, type: 'loader', callback: LoaderExtendCallback): void;
    extend(name: string, type: 'formatter', callback: FormatterExtendCallback): void;
}
