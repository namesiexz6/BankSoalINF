"use strict";
/*
 * @adonisjs/i18n
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Formatter = void 0;
/// <reference path="../../../adonis-typings/index.ts" />
const luxon_1 = require("luxon");
const intl_formatter_1 = require("@poppinss/intl-formatter");
const RelativeTime_1 = require("../RelativeTime");
/**
 * Core formatter to format different values using the I18n API
 */
class Formatter {
    constructor(locale) {
        this.locale = locale;
    }
    /**
     * Returns the diff between the current time and the user provided date
     *
     * - If the value is a string, we consider it as an ISODateTime string
     * - If value is a number, then we consider it as a diff in the user provided unit.
     */
    getTimeDiff(value, unit) {
        const diffUnit = unit === 'auto' ? 'milliseconds' : unit;
        /**
         * Returns the diff from the ISODateTime string. The diff is calculated
         * in milliseconds when the user provided unit is auto.
         */
        if (typeof value === 'string') {
            return luxon_1.DateTime.fromISO(value).diff(luxon_1.DateTime.local(), diffUnit)[diffUnit];
        }
        /**
         * Returns the diff from the luxon datetime instance. The diff is calculated
         * in milliseconds when the user provided unit is auto.
         */
        if (luxon_1.DateTime.isDateTime(value)) {
            return value.diff(luxon_1.DateTime.local(), diffUnit)[diffUnit];
        }
        /**
         * Returns the diff from the luxon date instance. The diff is calculated
         * in milliseconds when the user provided unit is auto.
         */
        if (value instanceof Date) {
            return luxon_1.DateTime.fromJSDate(value).diff(luxon_1.DateTime.local(), diffUnit)[diffUnit];
        }
        /**
         * Consider user provided value itself as a diff
         */
        return value;
    }
    /**
     * Formats a numeric value
     */
    formatNumber(value, options) {
        value = typeof value === 'string' ? Number(value) : value;
        return intl_formatter_1.formatters.number(this.locale, options).format(value);
    }
    /**
     * Formats a numeric value to a currency display value
     */
    formatCurrency(value, options) {
        const currencyOptions = { style: 'currency', ...options };
        return this.formatNumber(value, currencyOptions);
    }
    /**
     * Formats date, luxon date, ISO date/time string or a timestamp to
     * a formatted date-time string
     */
    formatDate(value, options) {
        let normalizedDate;
        if (typeof value === 'string') {
            normalizedDate = luxon_1.DateTime.fromISO(value).toJSDate();
        }
        else if (luxon_1.DateTime.isDateTime(value)) {
            normalizedDate = value.toJSDate();
        }
        else {
            normalizedDate = value;
        }
        return intl_formatter_1.formatters.date(this.locale, options).format(normalizedDate);
    }
    /**
     * Formats date, luxon date, ISO date/time string or a timestamp to
     * a formatted time string
     */
    formatTime(value, options) {
        if (!options) {
            options = { timeStyle: 'medium' };
        }
        else if (!options.hour && !options.minute && !options.second) {
            options = { timeStyle: 'medium', ...options };
        }
        return this.formatDate(value, options);
    }
    /**
     * Format a date, luxon date, ISO date/time string or a diff value
     * to a relative difference string
     */
    formatRelativeTime(value, unit, options) {
        const diff = this.getTimeDiff(value, unit);
        const formatter = intl_formatter_1.formatters.relative(this.locale, { ...(options || {}) });
        return unit === 'auto'
            ? (0, RelativeTime_1.format)(formatter, diff)
            : formatter.format(typeof value === 'number' ? diff : Math.floor(diff), unit);
    }
    /**
     * Format the value to its plural counter part
     */
    formatPlural(value, options) {
        return intl_formatter_1.formatters.plural(this.locale, options).select(Number(value));
    }
}
exports.Formatter = Formatter;
