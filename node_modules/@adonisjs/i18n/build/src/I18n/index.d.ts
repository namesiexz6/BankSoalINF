/// <reference path="../../adonis-typings/index.d.ts" />
/// <reference types="@adonisjs/events/build/adonis-typings" />
/// <reference types="@adonisjs/logger/build/adonis-typings/logger" />
import { LoggerContract } from '@ioc:Adonis/Core/Logger';
import { EmitterContract } from '@ioc:Adonis/Core/Event';
import { I18nContract, I18nManagerContract, ValidatorWildcardCallback } from '@ioc:Adonis/Addons/I18n';
import { Formatter } from '../Formatters/Core';
/**
 * I18n class works with a dedicated locale at a given point
 * in time
 */
export declare class I18n extends Formatter implements I18nContract {
    locale: string;
    private emitter;
    private logger;
    private i18nManager;
    /**
     * Locale translations
     */
    private localeTranslations;
    /**
     * Fallback translations
     */
    private fallbackTranslations;
    /**
     * The fallback locale for the current instance.
     */
    get fallbackLocale(): string;
    constructor(locale: string, emitter: EmitterContract, logger: LoggerContract, i18nManager: I18nManagerContract);
    /**
     * Load translations from the i18nManager. Note, this method doesn't load
     * translations from the configured loaders. It just asks the i18nManager
     * to return cached translations for the selected locale.
     */
    private loadTranslations;
    /**
     * Lazy load translations. Doing this as i18n class usually results in switchLocale
     * during real world use cases
     */
    private lazyLoadTranslations;
    /**
     * Emits the missing translation message
     */
    private notifyForMissingTranslation;
    /**
     * Returns the message for a given identifier
     */
    private getMessage;
    /**
     * Formats the validator message (if exists) otherwise returns null
     */
    private formatValidatorMessage;
    /**
     * Returns a boolean identifying if the message for a given
     * identifier exists or not
     */
    hasMessage(identifier: string): boolean;
    /**
     * Returns a boolean identifying if a fallback message for a given
     * identifier exists or not
     */
    hasFallbackMessage(identifier: string): boolean;
    /**
     * Switch locale for the current instance
     */
    switchLocale(locale: string): void;
    /**
     * Returns a wildcard function to format validation
     * failure messages
     */
    validatorMessages(messagesPrefix?: string): {
        '*': ValidatorWildcardCallback;
    };
    /**
     * Formats a message using the messages formatter
     */
    formatMessage(identifier: string, data?: Record<string, any>, fallbackMessage?: string): string;
    /**
     * Formats a message using the messages formatter
     */
    formatRawMessage(message: string, data?: Record<string, any>): string;
}
