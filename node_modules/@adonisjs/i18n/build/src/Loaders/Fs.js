"use strict";
/*
 * @adonisjs/i18n
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FsLoader = void 0;
/// <reference path="../../adonis-typings/index.ts" />
const yaml_1 = __importDefault(require("yaml"));
const fs_1 = require("fs");
const path_1 = require("path");
const utils_1 = require("@poppinss/utils");
const helpers_1 = require("@poppinss/utils/build/helpers");
/**
 * Uses the filesystem to load messages from the JSON
 * files
 */
class FsLoader {
    constructor(config) {
        this.config = config;
        this.allowedExtensions = ['.json', '.yaml', '.yml'];
    }
    /**
     * Returns the file contents
     */
    getFileContents(filePath) {
        return new Promise((resolve, reject) => {
            (0, fs_1.readFile)((0, path_1.join)(this.config.location, filePath), 'utf-8', (error, contents) => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve(contents);
            });
        });
    }
    /**
     * Processes the messages for a given file and writes them to the
     * messages bag.
     *
     * @note: The messagesBag property is mutated internally
     */
    processFileTranslations(filePath, messages, messagesBag) {
        const [lang, ...nestedPath] = filePath
            .replace(new RegExp(`${(0, path_1.extname)(filePath)}$`), '')
            .split(/\/|\\/g);
        /**
         * Initialize/use the language node
         */
        messagesBag[lang] = messagesBag[lang] || {};
        /**
         * If the file path is not nested, then consider the file
         * messages to belong directly to the language
         */
        if (!nestedPath.length) {
            messagesBag[lang] = messages;
            return;
        }
        /**
         * Otherwise create a sub node for messages.
         */
        messagesBag[lang][nestedPath.join('.')] = messages;
    }
    /**
     * Wraps JSON.parse to raise exception with the file path when
     * unable to parse JSON
     */
    parseJSON(filePath, contents) {
        try {
            return JSON.parse(contents);
        }
        catch (error) {
            const stack = error.stack.split('\n');
            /**
             * Patching the stack to include the JSON file path
             */
            stack.splice(1, 0, `    at anonymous (${filePath})`);
            error.stack = stack.join('\n');
            throw error;
        }
    }
    /**
     * Processes the message inside a JSON file
     */
    async processJSONFile(filePath, messagesBag) {
        const contents = await this.getFileContents(filePath);
        const messages = this.parseJSON(filePath, contents);
        this.processFileTranslations(filePath, messages, messagesBag);
    }
    /**
     * Wraps JSON.parse to raise exception with the file path when
     * unable to parse JSON
     */
    parseYaml(filePath, contents) {
        try {
            return yaml_1.default.parse(contents);
        }
        catch (error) {
            const offset = error.source?.range?.start;
            const stack = error.stack.split('\n');
            if (offset) {
                stack[0] = `${stack[0]} (at offset ${offset})`;
            }
            /**
             * Patching the stack to include the JSON file path
             */
            stack.splice(1, 0, `    at anonymous (${filePath})`);
            error.stack = stack.join('\n');
            throw error;
        }
    }
    /**
     * Processes the message inside a YAML file
     */
    async processYamlFile(filePath, messagesBag) {
        const contents = await this.getFileContents(filePath);
        const messages = this.parseYaml(filePath, contents);
        this.processFileTranslations(filePath, messages, messagesBag);
    }
    /**
     * Returns an array of file paths for translation files. Only
     * collects files ending with ".json" and ".yaml"
     */
    getTranslationFiles() {
        return (0, helpers_1.fsReadAll)(this.config.location, (file) => !!this.allowedExtensions.find((ext) => file.endsWith(ext)));
    }
    /**
     * Loads messages from the lang directory
     */
    async load() {
        const messagesBag = {};
        await Promise.all(this.getTranslationFiles().map((file) => {
            if (file.endsWith('.json')) {
                return this.processJSONFile(file, messagesBag);
            }
            else {
                return this.processYamlFile(file, messagesBag);
            }
        }));
        return Object.keys(messagesBag).reduce((result, lang) => {
            result[lang] = (0, utils_1.flatten)(messagesBag[lang]);
            return result;
        }, {});
    }
}
exports.FsLoader = FsLoader;
